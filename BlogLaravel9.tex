% Created 2022-12-01 jue 21:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}

\usepackage{parskip}
\usepackage[utf8]{inputenc} %% For unicode chars
\usepackage{placeins}
\usepackage[margin=1.5cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage{mathpazo}
\linespread{1.05}
\usepackage[scaled]{helvet}
\usepackage{courier}
\hypersetup{colorlinks=true,linkcolor=blue}
\RequirePackage{fancyvrb}
\AtBeginEnvironment{noerr}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\usepackage{mdframed}
\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}
\setcounter{secnumdepth}{4}
\date{}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.5.5)}, 
 pdflang={Spanish}}
\begin{document}

\setcounter{tocdepth}{3}
\tableofcontents

\setlength\parindent{10pt}


\section{Blog con Laravel 9 sail}
\label{sec:orgca1c5c4}
El código del proyecto se puede encontrar \href{https://github.com/IES-Rafael-Alberti/blog-laravel9.git}{aquí}.


\subsection{Crear proyecto}
\label{sec:org9d395e2}
\begin{minted}[]{bash}
curl -s https://laravel.build/blog-laravel9 | bash
cd curso-basico-laravel9
sail up
\end{minted}

\subsection{Modelo de datos}
\label{sec:orge902f73}
\subsubsection{Modelos y sus migraciones}
\label{sec:orgd202ef9}

\begin{enumerate}
\item Creamos el modelo \emph{Category} y su migración añadiendo \texttt{-m}
\label{sec:org305dcde}
\begin{minted}[]{bash}
sail artisan make:model Category -m
\end{minted}

Vamos a modificar la migración creada para poner las columnas
necesarias para nuestra tabla. El modelo tendrá una columna \texttt{id()} de
tipo \texttt{BigInteger Unsigned Primary Key}, y una columna para el nombre
de tipo \texttt{Varchar de 40}:
\begin{minted}[]{php}
<?php
···
public function up()
{
    Schema::create('categories', function (Blueprint $table)
    {
        $table->id();
        $table->string("name", 40)->unique();
    });
}
···
\end{minted}

Observa que en Laravel 9 (realmente desde la 7) la función \texttt{id()},
hace todo lo necesario sin necesidad de especificar el tipo o primary
key...

Varchar viene expresado como string.

\item Ahora el modelo \emph{Article}
\label{sec:orga3ca860}
\begin{minted}[]{bash}
sail artisan make:model Article -m
\end{minted}

Un artículo tendrá una categoría (\emph{Category}) y un usuario creador
(\emph{user}), por lo que enlazaremos con las tablas correspondientes con
una «foreign key». El orden de creación de las migraciones es
relevante. Además tendrá un título y el contenido. En este caso tendrá
dos campos para indicar el momento de la creación y cuando ha sido
modificado.

\begin{minted}[]{php}
<?php
···
public function up()
{
    Schema::create('articles', function (Blueprint $table)
    {
        $table->id();
        $table->foreignIdFor(\App\Models\User::class)->constrained();
        $table->foreignIdFor(\App\Models\Category::class)->constrained();
        $table->string("title", 80)->unique();
        $table->text("content");
        $table->timestamps();
    });
}
···
\end{minted}
\end{enumerate}

\subsubsection{Modelo Category}
\label{sec:org39fa3f8}
Vamos a tocar el modelo creado automáticamente para ajustarlo.
\begin{minted}[]{php}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Category extends Model
{
    use HasFactory;

    // por defecto Laravel crea timpestamps y esta variable es true
    // con false le indicamos al ORM que no existen
    public $timestamps = false;

    // evitar ataques de asignación masiva
    protected $fillable = [
        "name",
    ];

   //Definimos la relación entre Category y Articles
   //Una categoría puede estar en muchos articulos
   //En principio un artículo sólo pertenece a una categoría,
   //así que es una relación de uno a muchos
   //Accediendo a la función articles, des un objeto de tipo Category,
   //podremos saber todos los artículos que tienen esa categoría.
    public function articles(): HasMany
    {
        return $this->hasMany(Article::class);
    }
}
\end{minted}

\newpage

\begin{enumerate}
\item Modelo Article
\label{sec:org9c149fa}
Aquí hay más cosas que cambiar:
\begin{minted}[]{php}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\Str;

class Article extends Model
{
    use HasFactory;
    //datos que permitimos rellenar
    protected $fillable = [
        "user_id", "category_id", "title", "content",
    ];
    //para la paginación, cuantos mostraremos por página
    //método paginate
    protected $perPage = 5;

    // método de Laravel que se ejecuta cuando se instancia un modelo
    protected static function boot()
    {
        parent::boot();
        //callback que recupera el id del autor y lo
        // relaciona con el user_id=> no es un campo rellenable
        // se rellena automáticamente con el id del usuario identificado
        self::creating(function (Article $article) {
            $article->user_id = auth()->id();
        });
    }

    //relación 1 a muchos, para saber a qué usaurio pertenece el artículo
    //
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
    //relación 1 a muchos, a qué categoría pertence el artículo
    public function category(): BelongsTo
    {
        return $this->belongsTo(Category::class);
    }

    //poner la hora en formato legible para nosotros
    //carbon librería para trabajar con fechas
    public function getCreatedAtFormattedAttribute(): string
    {
        return \Carbon\Carbon::parse($this->created_at)->format('d-m-Y H:i');
    }
    //accesor para obtener un extracto del contenido del artículo
    public function getExcerptAttribute(): string
    {
        return Str::excerpt($this->content);
    }
}
\end{minted}
\textbf{Nota: excerpt} Por si a alguien le pasa, o no. La función \texttt{excerpt}
ha funcionado bien con los artículos creados desde los \texttt{seeders} y
\texttt{factories}; sin embargo, con artículos creados desde el formulario
falla, no sé la razón. La  solución ha sido cambiar:
\begin{minted}[]{php}
<?php
Str::excerpt(value: $this->content);
\end{minted}
por
\begin{minted}[]{php}
<?php
Str::words(value: $this->content, words: 90);
\end{minted}
Donde 90, puede ser 100 o la cantidad de palabras que queráis que se
muestren.

\item Modelo User
\label{sec:org0f6d0f8}
Vamos a reutilizar el modelo que viene predefinido en Laravel, vamos a
dejarlo casi tal cual viene, pero vamos a añadir la relación con los artículos:
\begin{minted}[]{php}
<?php
//Un usuario va a tener muchos (hasMany) articles
public function articles(): HasMany
{
    return $this->hasMany(Article::class);
}
\end{minted}
\end{enumerate}

\subsection{Seeders y Factories}
\label{sec:org3c3cfdc}
Los «Seeders» (sembradores), junto con las Factories (factorías), son un
medio para introducir datos de prueba, falsos, en la BD y poder probar
la aplicación.

\begin{enumerate}
\item Seeder de Category
\label{sec:org3bd1d88}
Vamos a crear un \emph{seeder} para Categoy:
\begin{minted}[]{bash}
sail artisan make:seed CategorySeeder
\end{minted}

Abrimos el fichero (en database/seeders) y lo modificamos:
\begin{minted}[]{php}
<?php

namespace Database\Seeders;

use App\Models\Category;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class CategorySeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
       // nuestros añadidos
       //Utilizamos nuestro modelo Category, y de este modelo
       //podemos usar varias funciones, insert para meter muchos datos
       //o create para un único dato. Vamos a utilizar insert, puesto
       // que vamos a introducir varios. Creamos un array por cada dato.
        Category::insert([
           ["name" => "Php",],
           ["name" => "Laravel",],
           ["name" => "Vue",],
           ["name" => "Docker",],
        ]);
    }
}
\end{minted}

Cuando ejecutamos los \emph{seeders}, el único que se ejecuta es el
\texttt{DatabaseSeeder}, para ejecutar los demás tendremos que registrarlos,
precisamente en \texttt{DatabaseSeeder}. Veremos dentro de un momento que
hacer para registrarlos.

Antes vamos ver cómo funcionan las factorías con una factoría para los
artículos:
\item Factory para Article.
\label{sec:org45e8eef}
Creamos la factoría como siempre, con artisan:

\begin{minted}[]{bash}
sail artisan make:factory ArticleFactory
\end{minted}

Abrimos \texttt{ArticleFactory} y lo modificamos para que quede así:
\begin{minted}[]{php}
<?php
namespace Database\Factories;

use App\Models\Category;
use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Article>
 */
class ArticleFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        //introducimos los campos que queremos con su tip
        //los "faker" ya vienen dentro de los facotry
        //no hay que instanciarlos
        //
        return [
            //texto aleatorio de 30 caracteres
            "title" => $this->faker->text(30),
            //texto aleatorio para el "content"
            "content" => $this->faker->text,
            //obtenemos todos los usuarios que tenemos y asignamos
            //uno aleatoriamente
            "user_id" => User::all()->random(1)->first()->id,
            //idem con las categorías
            "category_id" => Category::all()->random(1)->first()->id,
            //hora de creación ahora con la función, de Carbon, now()
            "created_at" => now(),
        ];
    }
}
\end{minted}

\item \textbf{Factory para Category}
\label{sec:orgb5b3e14}
Creada con:
\begin{minted}[]{bash}
sail artisan make:factory CategoryFactory
\end{minted}

Que modificamos y queda:
\begin{minted}[]{php}
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Article>
 */
class CategoryFactory extends Factory
{
    public function definition(): array
    {
        return [
            "name" => $this->faker->text(30),
        ];
    }
}
\end{minted}

\item \textbf{Actualizar DatabaseSeeder}
\label{sec:orgaad8a6a}
Para utilizar todo lo creado, debemos ir a DatabaseSeeder y registrar
el seeder y la factory creados:

\begin{minted}[]{php}
<?php

namespace Database\Seeders;

use App\Models\Article;
use App\Models\User;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        //creamos un usuario con la User::factory
        //le pasamos datos, así que no usará lo del factory
        User::factory()->create([
            "name" => "CursosDesarrolloWeb",
            "email" => "laravel9@blogweb.es",
        ]);
        User::factory()->create([
            "name" => "Soporte",
            "email" => "soporte@blogweb.es",
        ]);
        //Para llamar al seeder sólo tenemos que llamarlo
        $this->call(CategorySeeder::class);
        //Creamos 20 artículos
        Article::factory(20)->create();
    }
}
\end{minted}

Nota:
\begin{mdframed}
No hemos mencionado la factoría de usuarios \texttt{UserFactory}, porque se
crea automáticamente al crear el proyecto Laravel, y no hemos
necesitado modificarla, sólo usarla. La puedes encontrar en
\texttt{database/factories/UserFactory.php}
\end{mdframed}


\item Ejecutar seeders
\label{sec:org0a4adc6}
Es el turno de ejecutar los seeders
\begin{minted}[]{bash}
sail artisan db:seed
\end{minted}

Algunas veces pueden repetirse filas, así que habrá que volver a
lanzar el seeder.

Además debemos modificar una función del modelo \texttt{Article} para poder
lanzar los seeders:
\begin{minted}[]{php}
<?php
protected static function boot()
{
        parent::boot();
        //callback que recupera el id del autor y lo
        // relaciona con el user_id=> no es un campo rellenable
        // se rellena automáticamente con el id del usuario identificado
        //Sólo se ejecutará si no estamos lanzando una operación desde consola,
        //porque no tenemos el usuario identificado
        if(!app()->runningInConsole())
        {
            self::creating(function (Article $article)
            {
                $article->user_id = auth()->id();
            });
        }
}
\end{minted}

Si ya habíamos lanzado los seeder, aunque lo arreglemos fallará,
porque se habrá ejecutado a medias, y ya habrá datos en BD. Así que
habrá que hacer algo:
\begin{minted}[]{bash}
sail artisan migrate:fresh --seed
\end{minted}

Con esto vaciamos las tablas, las eliminamos, recreamos y las
rellenamos con los seeders.
\end{enumerate}



\subsection{Autenticación en Laravel}
\label{sec:orgf0b2671}
El siguiente paso es realizar el sistema de autenticación de nuestro
blog. Para ello usaremos Breeze, una librería de Laravel:

\begin{enumerate}
\item \textbf{Laravel Breeze}
\label{sec:org7b70ee5}
Laravel Breeze es una implementación simple y mínima de todas las
funciones de autenticación de Laravel, incluido el inicio de sesión,
el registro, el restablecimiento de contraseña, la verificación de
correo electrónico y la confirmación de contraseña. La capa de vista
de Laravel Breeze se compone de plantillas Blade simples diseñadas con
Tailwind CSS. Para comenzar, consulte la documentación sobre los kits
de inicio de aplicaciones de Laravel.

Otras alternativas son:
\item \textbf{Laravel Fortify} es un backend de autenticación sin cabeza para Laravel
\label{sec:org92c7d7d}
que implementa muchas de las funciones que se encuentran en esta
documentación, incluida la autenticación basada en cookies y otras
funciones como la autenticación de dos factores y la verificación de
correo electrónico. Fortify proporciona el backend de autenticación
para Laravel Jetstream o se puede usar de forma independiente en
combinación con Laravel Sanctum para proporcionar autenticación para
un SPA que necesita autenticarse con Laravel.

\item \textbf{Laravel Jetstream} es un sólido kit de inicio de aplicaciones que
\label{sec:org50a193d}
consume y expone los servicios de autenticación de Laravel Fortify con
una hermosa y moderna interfaz de usuario impulsada por Tailwind CSS,
Livewire o Inertia. Laravel Jetstream incluye soporte opcional para
autenticación de dos factores, soporte de equipo, administración de
sesiones de navegador, administración de perfiles e integración
incorporada con Laravel Sanctum para ofrecer autenticación de token
API. Las ofertas de autenticación de API de Laravel se analizan a
continuación.

Aunque Laravel Breeze no nos ofrece tantas funcionalidades como
Jetstream: 2FA, Inertia o Livewire, sí nos ofrece lo básico para
cualquier proyecto, un completo proceso de autenticación, registro,
login, confirmación de correo electrónico y recuperación de
contraseña, y todo esto publicando todos los recursos en nuestro
proyecto, tanto vistas con blade como controladores y
requests. Instalar Laravel Breeze Para empezar a utilizar Laravel
Breeze en tu proyecto Laravel simplemente sigue estos pasos (forma
recomendada de instalar Breeze):

\begin{minted}[]{bash}
#Instala la dependencia Breeze
sail composer require laravel/breeze --dev
#Se monta el "andamio", en la aplicación, para usar
#autenticación con Breeze
sail artisan breeze:install
\end{minted}

Vamos a trabajar con Laravel Blade para las vistas, es la forma más
sencilla. No es la más potente ni la única, Laravel se puede integrar
fácilmente con Vue y con React, y con un poco más de trabajo con
Mithril.js...


Podemos comprobar que está instalado mirando que en \texttt{Controllers}
tenemos el nuevo directorio \texttt{Auth} con todas las partes de la
autenticación. Tenemos nuevos directorios y vistas en resources/views,
entre otros \texttt{auth} (vistas de autenticación), \texttt{components}
(componentes Blade que podemos utilizar en nuestra aplicación),
\texttt{layouts} (diseño para usuarios autenticados, para invitados,
navegación con acceso al dashboard -lo que se muestra al entrar en la
página-).

Además ejecutando el siguiente comando y viendo que se han añadido
nuevas rutas:
\begin{minted}[]{bash}
sail artisan route:list
\end{minted}

Luego vamos a ejecutar \texttt{yarn} (alternativa a \texttt{npm}) para bajar las
dependencias del lado del cliente y hacer seguimiento de los cambios
que hagamos en el lado del cliente (para que se actualicen las
vistas... sin necesidad de relanzar la aplicación).

Laravel con webpack/laravel-mix versiones < 9.19.0:
\begin{minted}[]{bash}
sail yarn && sail yarn watch
\end{minted}
o bien
\begin{minted}[]{bash}
sail npm install && sail npm run watch
\end{minted}

Laravel con vite, versiones >= a la 9.19.0:
\begin{minted}[]{bash}
sail yarn  && sail yarn dev
\end{minted}
o bien
\begin{minted}[]{bash}
sail npm install && sail npm run dev
\end{minted}

Webpack de laravel-mix y vite son herramientas para construir la parte
«front-end» de una aplicación web, siendo vite más moderno y la
herramienta de construcción que viene con la versión de Laravel que
estamos usando.

Si alguien quiere, o necesita, volver a Laravel Mix, \href{https://github.com/laravel/vite-plugin/blob/main/UPGRADE.md\#migrating-from-vite-to-laravel-mix}{aquí hay una guía}
para hacerlo.

Una vez llegados a este punto ya podemos entrar en \texttt{localhost} y ver
que nuestro sistema de "Login" está en marcha.

Versiones anteriores de Laravel usaban Bootstrap como framework de
CSS, pero esta versión que estamos usando utiliza Tailwind.
\end{enumerate}

\subsection{Controladores, recursos y rutas. Tests parte 1.}
\label{sec:orgc62f0bd}
\subsubsection{Controlador de artículo: «ArticleController»}
\label{sec:orgbba4c35}
Vamos a empezar con el blog, para ello creamos nuestro primer
controlador. El controlador es el puente entre la vista y el modelo y
se ejecuta a través de las rutas definidas en el sistema de rutas.

El controlador va a ser del tipo \emph{resource} (recurso), lo indicamos
con el \emph{flag} \texttt{-r}. Al ser del tipo recurso nos va a crear
automáticamente los métodos:
\begin{itemize}
\item \texttt{index}: listar los artículos
\item \texttt{create}: mostrar el formulario de creación
\item \texttt{store}: guardar un artículo en BD
\item \texttt{show}: mostrar un artículo en detalle
\item \texttt{edit}: mostrar el formulario de edición de artículos
\item \texttt{update}: actualizar el artículo que hayamos estado editando
\item \texttt{destroy}: eliminar un recurso(artículo) de la base de datos
\end{itemize}

Básicamente todo lo que necesitamos para un CRUD.

Le vamos a pasar otra opción \texttt{-{}-model=Article} para indicarle que el
que vamos a gestionar objetos de tip \texttt{Article}.
autoEjecutamos:
\begin{minted}[]{bash}
sail artisan make:controller ArticleController -r --model=Article
\end{minted}

Si vamos al directorio de controladores vemos nuestro
ArticleController.

\begin{enumerate}
\item \textbf{Creación de los tests}
\label{sec:orgb3e013f}
Más adelante veremos otra forma de hacer tests con el plugin Pest,
pero por ahora vamos a verlos tal y como los incorpora Laravel.  En
los controladores, la idea es crear un test por cada función del
controlador.
\begin{minted}[]{bash}
sail artisan make:test Http/Controllers/ArticleController/IndexTest
     [--unit][--pest]
\end{minted}

Por defecto para Laravel todo son «feature tests» (carpeta
\texttt{tests/Features}), si queremos crear test unitarios, en su
correspondiente carpeta \texttt{/tests/Unit} hay que usar la opción
\texttt{-{}-unit}. La opción \texttt{-{}-pest}, es para usar el framework, de tests,
Pest, que veremos más adelante.

Mirad el detalle de, que el nombre acaba en \texttt{Test}, para ayudar a
Laravel a descubir los tests.

En general crearemos tests de características (feature tests), puesto
que probamos funcionalidades completas y no funciones individuales
desconectadas del resto.

Podemos hacer un fichero de test para cada función del controlador, o
hacer un fichero único con todos los tests del controlador, como en el
ejemplo.

Una vez terminados los tes podemos hacer (cualquiera de ellas):
\begin{minted}[]{bash}
sail test
sail test --group orders
sail artisan test
\end{minted}

Más adelante veremos otras alternativas que facilitan el testing.
\end{enumerate}


\subsubsection{Actualizar rutas}
\label{sec:org3a4aacb}
Si vamos a nuestro archivo de rutas ahora vemos que hay nuevas rutas
que antes no teníamos. Entre otras se hace inclusión del fichero
\texttt{routes/auth.php}, en el que están todas las rutas necesarias para todas
las tareas de autenticación.

Pues bien, vamos a añadir una ruta para el controlador de artículos:
\begin{minted}[]{php}
<?php

Route::resource("articles", \App\Http\Controllers\ArticleController::class)
    ->middleware("auth");
\end{minted}

Con esto estamos añadiendo todas las rutas para el CRUD de Article. En
versiones anteriores habría que poner las rutas para cada una de las
operaciones del CRUD. Además, por usar el middleware auth, no es
posible ir a esta página sin estar autenticado.

\subsubsection{Listado y paginación de artículos}
\label{sec:orgfd1b749}
Nos vamos a \texttt{ArticleController}, al principio, a la función \texttt{index()}
que es la que servirá para hacer el listado de artículos. La opción
por defecto de \texttt{index()} es devolver un objeto de tipo \texttt{Response}, pero
nosotros vamos a devolver un \texttt{Renderable} de \texttt{Illuminate}. Con esto
queremos decir que vamos a devolver una vista. Quedará así:
\begin{minted}[]{php}
<?php

/**
 * Display a listing of the resource.
 *
 * @return Renderable
 */
public function index(): Renderable
{
    $articles = Article::with("category")->latest()->paginate();
    //dd($articles)
    return view("articles.index", compact("articles"));
}
\end{minted}
Con esto vamos a retornar todos los artículos, incluida su
categoría. Con el método \texttt{with} le decimos que queremos cargar una
relación, en este caso "category". Podríamos indicar las columnas que
queremos así: \texttt{"category:id,name}, pero como sólo tiene dos columnas
no ponemos nada y las recuperamos todas. También vamos a decir que
queremos ordenar por la fecha de lata. Para ello usamos el método
\texttt{latest()} para obtener desde el final. Finalmente llamamos a la
función \texttt{paginate()}, que nos devuelve todos los resultados, pero
paginados. Si queremos saber que está pasando, podemos usar la
función, antes del return, \texttt{dd(\$articles)}, para ver la información
que pasa por ahí. Recordad, que la paginación muestra 5 artículos,
porque así lo configuramos en el modelo.

Al final hacemos un \texttt{return view...}. Tenemos que crear la vista, para
ello creamos el fichero \texttt{index.blade.php} en
\texttt{resources/views/articles} (a veces PHPStorm te ayuda y te propone
crear esa vista, supongo que con el plugin de pago, o el gratis que no
está disponible para la última versión de PHPStorm; lo que sí se puede
hacer «seguro», es crear los tests, pulsamos \texttt{Alt+Insert} y en el menú,
una de las opciones, es Test...).

Vamos a modificar también el fichero \texttt{navigation.blade.php"}, vamos a
\texttt{<!-{}- Navigation Links -{}->}, y duplicamos el \texttt{x-nav-link} modificando
las rutas adecuadamente:

\begin{minted}[]{html}
<!-- Navigation Links -->
<div class="hidden space-x-8 sm:-my-px sm:ml-10 sm:flex">
    <x-nav-link :href="route('dashboard')"
                :active="request()->routeIs('dashboard')">
        {{ __('Dashboard') }}
    </x-nav-link>
  <div class="hidden space-x-8 sm:-my-px sm:ml-10 sm:flex">
    <x-nav-link :href="route('articles.index')"
                :active="request()->routeIs('articles.*')">
      {{ __('Artículos') }}
    </x-nav-link>
</div>
\end{minted}

Cuando creamos un controlador de tipo resource, como hicimos antes, se
crean una serie de rutas para todas las funciones de ese resource, así
ya tenemos creadas las rutas, \texttt{article.index, article.destroy}...

Con lo anterior hacer que, en la barra de navegación, aparezca el
enlace a la ruta \texttt{article.index}, pero sólo si estamos en alguna ruta
de "articles" \texttt{:active="request()->routeIs('articles.*')} \\
\texttt{\{\{ \_\_('Artículos') \}\}}.

Ahora vamos al Dashboard \texttt{dashboard.blade.php}. Observemos la etiqueta
\texttt{<x-app-layout>}, nos está indicando que usa el layout \emph{app}, en el
fichero \texttt{app.blade.php}. Mirando en ese fichero vemos que es la
disposición de base/layout (plantilla base) de nuestra aplicación. En
él vemos que tenemos las partes que muestran la navegación, la
cabecera, pie... Copiamos el contenido de \texttt{app.blade.php}, lo pegamos
y lo iremos modificando. Podéis probar a quitar y poner cosas, y recargar.

Vamos a dar formato a nuestro listado de artículos, para eso vamos a
usar Tailwind, que ya viene en Laravel. Vamos a \href{https://tailblocks.cc}{tailblocks}, donde
veremos bloques ya construidos con los que trabajar. Dentro de la
cuarta opción, le damos a ver código y copiamos el siguiente trozo (y
cerramos las etiqueta que queden abiertas):
\begin{minted}[]{html}
<section class="text-gray-600 body-font overflow-hidden">
  <div class="container px-5 py-24 mx-auto">
    <div class="-my-8 divide-y-2 divide-gray-100">
      <div class="py-8 flex flex-wrap md:flex-nowrap">
        <div class="md:w-64 md:mb-0 mb-6 flex-shrink-0 flex flex-col">
          <span class="font-semibold title-font text-gray-700">
            CATEGORY
          </span>
          <span class="mt-1 text-gray-500 text-sm">12 Jun 2019</span>
        </div>
        <div class="md:flex-grow">
          <h2 class="text-2xl font-medium text-gray-900 title-font mb-2">
            Bitters hashtag waistcoat fashion axe chia unicorn
          </h2>
          <p class="leading-relaxed">
            Glossier echo park pug, church-key sartorial biodiesel
            vexillologist pop-up snackwave ramps cornhole.
            Marfa 3 wolf moon party messenger bag selfies,
            poke vaporware kombucha lumbersexual pork belly
            polaroid hoodie portland craft beer.
          </p>
          <a class="text-indigo-500 inline-flex items-center mt-4">Learn More
            <svg class="w-4 h-4 ml-2" viewBox="0 0 24 24"
                 stroke="currentColor" stroke-width="2"
                 fill="none" stroke-linecap="round"
                 stroke-linejoin="round">
              <path d="M5 12h14"></path>
              <path d="M12 5l7 7-7 7"></path>
            </svg>
          </a>
        </div>
      </div>
    </div>
  </div>
</section>
\end{minted}

Vemos que el contenido realmente está en la etiqueta \texttt{<div class="-my-8 divide-y-2} \\
\texttt{divide-gray-100">}, vamos a poner directivas Blade para repetir una
acción, listar, para cada artículo...:
\begin{minted}[]{html}
<section class="text-gray-600 body-font overflow-hidden">
  <div class="container px-5 py-24 mx-auto">
    <div class="-my-8 divide-y-2 divide-gray-100">
       @foreach($articles as $article)
       <div class="py-8 flex flex-wrap md:flex-nowrap">
        ···
      </div>
      @endforeach
    </div>
  </div>
</section>
\end{minted}

Vamos a modificar para mostrar lo que queremos.

\begin{itemize}
\item Cambiamos CATEGORY por la categoría del artículo, que viene en la
variable de cada objeto de tipo Article.
\end{itemize}
\begin{minted}[]{html}
<span class="font-semibold title-font text-gray-700">
  {{ $article->category->name }}</span>
\end{minted}

\begin{itemize}
\item Cambiamos la fecha puesta a dedo por la fecha del artículo real, con
el accesor que creamos al principio:
\end{itemize}
\begin{minted}[]{hmtl}
<span class="mt-1 text-gray-500 text-sm">{{ $article->created_at_formmatted }}</span>
\end{minted}

\begin{itemize}
\item Cambiamos el título:
\end{itemize}
\begin{minted}[]{html}
<h2 class="text-2xl font-medium text-gray-900 title-font mb-2">
  {{ $article->title }}
</h2>
\end{minted}

\begin{itemize}
\item Cambiamos el contenido por el extracto:
\end{itemize}
\begin{minted}[]{html}
<p class="leading-relaxed">
  {{ $article->excerpt }}
</p>
\end{minted}

Ya nos queda añadir los enlaces de paginación, que es tan fácil como,
tras el \texttt{@endforeach}, añadir:
\begin{minted}[]{php}
@endforeach
{{ $article->links() }}
\end{minted}
y Laravel ya hace el resto por nosotros.

\subsubsection{Creación de artículos}
\label{sec:org44984d7}
Antes de ir a hacer el formulario de creación de artículos y la
función del controlador que lo llama, vamos a crear un botón en la
vista \emph{index} para dar acceso a ese formulario de creación. Es
simplemente un enlace con la función de ayuda (o helper) \texttt{route()} a
la función create del controlador de artículos:

\begin{minted}[]{html}
<div class="mb-16 -my-8">
   <a href="{{ route("articles.create") }}"
      class="flex w-64 text-white bg-indigo-500
             border-0 py-2 px-8 focus:outline-none
             hover:bg-indigo-600 rounded text-lg">
      {{ __("Crear un nuevo artículo") }}
   </a>
</div>
\end{minted}
Ahora mismo la función del controlador está vacía y no nos devuelve nada.

Creamos la función \emph{create}:

\begin{minted}[]{php}
<?php
 /**
 * Show the form for creating a new resource.
 *
 * @return Renderable
 */
public function create(): Renderable
{
  $article = new Article; //
  $title = __("Crear artículo");
  //ruta para el procesado del contenido
  //devuelto por el formulario
  $action = route("articles.store");
  return view("articles.form", compact("article", "title", "action"));
}
\end{minted}

Dentro de la función hemos definido un nuevo artículo, para
representar el formulario, que mostraremos después. Vamos a tener un
título y una acción, donde vamos a procesar el formulario, que
simplemente será la ruta de la función que recogerá los datos del
formulario y los almacenará en BD. Finalmente retornamos una vista,
\texttt{articles.form}, con todos esos parámetros. \texttt{articles.form} indica que
accedemos a una vista \texttt{form} dentro de la carpeta \texttt{articles} (en
\texttt{view}, claro). En Laravel muchas veces veremos, en el código, la
notación con punto para rutas en el árbol de ficheros:
\texttt{articles.form} equivale a \texttt{view/articles/form.blade.php}

El formulario nos servirá tanto para crear nuevos artículos, como para
editarlos; economía del esfuerzo\^{}\_\^{}.

Hay diversas manera de pasar parámetros a una vista, una de ellas es
compact. Es la más sencilla; como inconveniente las variables que
pasamos aquí, se tienen que llamar igual en el lugar de recepción.


Para el formulario vamos de nuevo a la página de bloques de TailWind y
cogemos el sexto elemento, \texttt{formulario de contacto}, copiamos el código,
lo pegamos en el formulario y lo revisamos para hacer algunos cambios.
Queda así:


\begin{minted}[]{html}
<x-app-layout>
  <x-slot name="header">
    <h2 class="font-semibold text-xl text-gray-800 leading-tight">
      {{ $title }}
    </h2>
  </x-slot>

  <div class="py-12">
    <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
      @if ($errors->any())
        <div class="bg-red-500 text-white p-4">
          <ul>
            @foreach ($errors->all() as $error)
              <li>{{ $error }}</li>
            @endforeach
          </ul>
        </div>
      @endif
      <form method="POST" action="{{ $action }}">
        @csrf
        @if($article->id)
          @method("PUT")
        @endif
        <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg p-6">
          <h2 class="text-gray-900 text-lg mb-1 font-medium title-font">
              {{ __("Escribe tu artículo") }}
          </h2>
          <div class="relative mb-4">
            <label for="title"
                   class="leading-7 text-sm text-gray-600">
                   {{ __("Título") }}
            </label>
            <input type="text" id="title" name="title"
                   value="{{ old("title", $article->title) }}"
                   class="w-full bg-white rounded border border-gray-300
                          focus:border-indigo-500 focus:ring-2
                          focus:ring-indigo-200 text-base outline-none
                          text-gray-700 py-1 px-3 leading-8
                          transition-colors duration-200 ease-in-out">
          </div>
          <div class="relative mb-4">
            <label for="category_id"
                   class="leading-7 text-sm text-gray-600">
                          {{ __("Título") }}</label>
            <select id="category_id" name="category_id"
                    class="w-full bg-white rounded border border-gray-300
                          focus:border-indigo-500 focus:ring-2
                          focus:ring-indigo-200 text-base outline-none
                          text-gray-700 py-1 px-3 leading-8
                          transition-colors duration-200 ease-in-out">
              @foreach(\App\Models\Category::get() as $category)
                <option
                  {{ (int) old("category_id",
                   $article->category_id) === $category->id ? 'selected'
                    : '' }} value="{{ $category->id }}">
                    {{ $category->name }}
                  </option>
              @endforeach
            </select>
          </div>
          <div class="relative mb-4">
            <label for="content"
                   class="leading-7 text-sm text-gray-600">
            {{ __("Artículo") }}
            </label>
            <textarea id="content" name="content"
                      class="w-full bg-white rounded border
                      border-gray-300 focus:border-indigo-500
                      focus:ring-2 focus:ring-indigo-200 h-32
                      text-base outline-none text-gray-700 py-1 px-3
                      resize-none leading-6 transition-colors
                      duration-200 ease-in-out">
                   {{ old("content", $article->content) }}
            </textarea>
          </div>
          <button type="submit"
                  class="text-white bg-indigo-500 border-0
                  py-2 px-6 focus:outline-none hover:bg-indigo-600
                  rounded text-lg">
                 {{ $title }}
          </button>
        </div>
      </form>
    </div>
  </div>
</x-app-layout>
\end{minted}

\begin{itemize}
\item \texttt{@if(\$errors)}, nos muestra los errores en el formulario.
\item El formulario usa el método \textbf{POST} con la acción \texttt{\{\{ \$action \}\}},
que viene desde el controlador. Pero si el \texttt{id} existe, estamos
modificando, no creando un artículo nuevo y necesitaríamos un \textbf{\texttt{PUT}}
estándar para modificación (también se suele usar \texttt{PATCH}), lo hacemos
con directivas Blade y así Laravel sabrá que es un \texttt{PUT}:
\begin{minted}[]{php}
@if($article->id)
    @method("PUT")
@endif
\end{minted}
\item \texttt{@csrf} Directiva para proteger el formulario contra XSS.Crea un
campo \texttt{hidden} en el formulario con un token. Cuando hagamos una
petición a Laravel se usará ese token para comprobar que la petición
se hace desde nuestro sitio y no desde otro (evitar XSS).

\item Se ha cambiado el \texttt{value} del siguiente código:
\begin{minted}[]{html}
<input type="text" id="title" name="title"
                 value="{{ old("title", $article->title) }}"
\end{minted}
Lo que hace es, si hemos mandado el formulario, desde edición, y la
validación del formulario ha fallado por lo que sea, se queda con el
título válido que tenía antes, si no simplemente va a recoger el
valor que habíamos enviado

\item Recogemos todas las categorías, podríamos hacerlo con el
controlador, o directamente como hemos hecho:
\begin{minted}[]{html}
@foreach(\App\Models\Category::get() as $category)
  <option  {{ (int) old("category_id",
     $article->category_id) === $category->id ? 'selected'
      : '' }} value="{{ $category->id }}">
      {{ $category->name }}
  </option>
@endforeach
\end{minted}
Observad la conversión a entero \texttt{(int)}, ¿se puede quitar y usar
\texttt{==} en lugar de \texttt{===}, porque serían dos cadenas? Si el \texttt{id} de la
categoría del artículo, nuevo o editado, se corresponde con lo que
había, se maraca como \texttt{selected}.
\end{itemize}

\subsubsection{Validación de formularios de forma segura con \texttt{Form Request} y match}
\label{sec:org6152220}
Lo primero que vamos a hacer es crear un Form Request con artisan:
\begin{minted}[]{bash}
sail artisan make:request ArticleRequest
\end{minted}
Los request en Laravel permiten interceptar la petición del formulario
para poder realizar las validaciones correctamente

Una vez creado el fichero en \texttt{Http/Requests/ArticleRequest} lo modificamos:
\begin{minted}[]{php}
<?php
namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize(): bool
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules(): array
    {
        return match ($this->method()) {
            "POST" => [
                "title" => "required|min:2|max:40|unique:articles",
                "content" => "required|min:10",
                "category_id" => "required|exists:categories,id",
            ],
            "PUT" => [
                "title" => "required|min:2|max:40|unique:articles,title," .
                           $this->route("article")->id,
                "content" => "required|min:10",
                "category_id" => "required|exists:categories,id",
            ],
        };
    }
}
\end{minted}

La función \texttt{authorize} debe devolver \texttt{true} para que se active la
siguiente función \texttt{rules()}, donde crearemos las reglas de validación
del formulario. Las condiciones para que se ejecuten las reglas las
controlamos nosotros con rutas, permisos o roles, como hemos hecho
nosotros con el \texttt{middleware auth} en las rutas.

En lugar de hacer un return directamente, lo habitual, vamos a
utilizar la función \texttt{match} de PHP 8 para comprobar si recibimos un
\texttt{POST}, creación, o un \texttt{PUT}, modificación.

Dentro de cada uno las reglas correspondientes, por ejemplo para
\texttt{title}, en creación, decimos que es obligatorio (\texttt{required}),
longitud mínima 2 (\texttt{min:2}), máxima 40 (\texttt{max:40}), lo definido para el
campo en la tabla), único (\texttt{unique}) en la tabla \texttt{articles} (hay que
validarlo aquí para no recibir un error al intentar insertar en la
tabla).

Lo mismo hacemos para \texttt{content}, mirad que hemos limitado el tamaño a
1000 para evitar errores (podemos ser más exactos mirando la longitud
máxima admitida para el tipo de campo generado para la BD usada).

Para \texttt{category\_id} tenemos que comprobar que, además de obligatorio,
existe ese \texttt{id} en la tabla \\
\texttt{categories}, pero allí no se llama \texttt{category\_id}, sino \texttt{id}, por
tanto debemos especificarlo \\
(\texttt{exists:categories,id}), para evitar problemas al consultar la BD.

Cuando estamos editando las reglas van a ser muy parecidas, con
algunos añadidos. En el caso del título tenemos que decirle que ese
título puede existir en el caso de que el \texttt{id} recuperado sea el \texttt{id}
\emph{actual} con el que trabajamos (para poder dejar el mismo título y que
al comprobar si existe un artículo con ese mismo título sepa que si es
el mismo \texttt{id}, no está repetido). Lo hacemos añadiendo
\texttt{.\$this->route("article")->id}.

Para los demás campos no vamos a tocar nada.

Más sobre validación de formularios \href{https://laravel.com/docs/9.x/validation\#form-request-validation}{aquí}.

Para ver todas las reglas que podemos usar podemos mirar en \href{https://laravel.com/docs/9.x/validation\#available-validation-rules}{este}
apartado de la web anterior.


\subsubsection{Persistir en BD los datos del formulario}
\label{sec:orgadf76c6}
Vamos a dar contenido a la función \texttt{store} de nuestro
\texttt{ArticleController}, que será la función que persistirá en BD, lo que
hemos introducido y validado en el formulario:
\begin{minted}[]{php}
<?php
/**
 * Store a newly created resource in storage.
 *
 * @param ArticleRequest $request
 * @return RedirectResponse
 */
public function store(ArticleRequest $request): RedirectResponse
{
  $validated = $request->safe()->only(['title', 'content', 'category_id']);
  $validated['user_id'] = auth()->id();
  Article::create($validated);
  //Para trabajar con traducciones la parte de __("...")
  session()->flash("success", __("El artículo ha sido creado correctamente"));
  return redirect(route("articles.index"));
}
\end{minted}
Por defecto se devuelve un objeto de tipo \texttt{Response}, pero nosotros
vamos a devolver uno del tipo \\
\texttt{RedirectResponse}, una vez almacenado el artículo vamos a ir al
listado de artículos para que se muestre que se ha creado.

Con \texttt{\$request->safe()->only(['title', 'content', 'category\_id']);}
indicamos que vamos a hacer una petición segura, cadenas escapadas,
verificadas... y además sólo permitimos los campos listado en el
\texttt{only}.


\subsubsection{Añadir flash en app.blade.php}
\label{sec:org6d281ac}
Para que se muestre el mensaje, vamos a \texttt{app.blade.php}, que es a
donde estamos redireccionando, y buscamos la sección \texttt{Page Content},
donde vemos la etiqueta \texttt{<main>}. Aquí vamos a «recibir» la sesión
creada en la función \texttt{store} («success»), y poner en la página el
mensaje enviado con la sesión:
\begin{minted}[]{php}
<?php
<!-- Page Content -->
<main>
  @if (session()->has("success"))
    <div class="bg-green-500 text-white p-4">
      <ul>
        <li>{{ session("success") }}</li>
      </ul>
    </div>
  @endif
      {{ $slot }}
</main>
\end{minted}

Así obtendremos el mensaje de creado correctamente cuando se cree un
artículo nuevo y se haya podido insertar en BD.


\textbf{Tareilla:} En este punto, podemos probar la validación del
formulario, enviando el formulario vacío o con datos fuera del rango
permitido.  Si cambiamos el \textbf{true} por \textbf{false} en la función
\texttt{authorize()} \\
de \texttt{ArticleRequest}, veremos que nos da un operación no autorizada.
Lo dejamos como estaba y seguimos con la prueba del formulario. Si lo
ponemos todo correctamente el \texttt{dd()} podemos ver lo que llega desde el
formulario.

\subsubsection{Editar artículos. Formulario en modo edición.}
\label{sec:org6c6d9a3}
Vamos a añadir lo necesario para poder editar un artículo. Como ya
avanzamos vamos a utilizar el mismo formulario que cuando creamos un
artículo.

Primero vamos a \texttt{index.blade.php} para añadir un enlace que nos lleve
a la edición del artículo. Vemos en nuestro código que hay un enlace
que pone \texttt{\{\{ \_\_("Ver detalle") \}\}}, que en el código original era
«Learn more» y lo hemos cambiado. Al final de ese bloque hemos añadido
un carácter de pipeline \texttt{|}. En este mismo bloque, antes de añadir, la
parte de editar, hemos añadido lo siguiente:

\begin{minted}[]{php}
<?php
href="{{ route("articles.show", ["article" => $article]) }}"
\end{minted}
Esto nos permite ir a mostrar el artículo al detalle, pero Laravel
necesita el \texttt{id} del artículo, para ello podemos pasarle en \texttt{id} o el
artículo completo. En este caso pasamos todo el artículo y Laravel ya
sabrá que hacer con él.

Lo siguiente es añadir un bloque similar al del detalle para la
edición del artículo:
\begin{minted}[]{php}
<?php
<a href="{{ route("articles.edit", ["article" => $article]) }}"
  class="text-indigo-500 inline-flex items-center mt-4">{{ __("Editar") }}
 <svg class="w-4 h-4 ml-2" viewBox="0 0 24 24"
       stroke="currentColor" stroke-width="2"
       fill="none" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M5 12h14"></path>
    <path d="M12 5l7 7-7 7"></path>
  </svg>
</a> |
\end{minted}
Observad a qué \texttt{url} vamos, \texttt{articles.edit}. Es la función del
controlador que vamos a implementar a continuación. También el
carácter de pipeline al final del bloque. Vamos a nuestro fichero
\texttt{ArticleController.php} y editamos el método \texttt{edit}
\begin{minted}[]{php}
<?php
/**
 * Show the form for editing the specified resource.
 *
 * @param Article $article
 * @return Renderable
 */
public function edit(Article $article): Renderable
{
    //dd($article);
    $title = __("Actualizar artículo");
    //***al pasar el $article, al ir al formulario ya estará todo relleno***
    $action = route("articles.update", ["article" => $article]);
    return view("articles.form", compact("article", "title", "action"));
}
\end{minted}

Observad que es muy parecido a lo que hicimos en la creación de
artículos. Devolvemos un \texttt{Renderable}, tenemos título, una acción
(llama al método update, situado debajo en la clase), crea la acción
que es una llamada a la ruta \texttt{"articles.update"} y devuelve la vista
\texttt{"articles.form"}, con los datos del artículo, el título y la
acción. El orden no importa. Como bonus mágico adicional, ya puesto
como comentario en el código, pasar a la ruta el artículo hace que, al
editar, el formulario esté relleno con los datos que tenía el artículo.

\subsubsection{Procesar edición de artículos. Actualizar registro en la BD.}
\label{sec:orgc339b99}
Este trozo de código que ya hemos mencionado anteriormente
\begin{minted}[]{php}
@if($article->id)
    @method("PUT")
@endif
\end{minted}
es el que permite que el método \texttt{update} sepa el tipo de petición,
POST o PUT, y entremos en modo edición y no creación de nuevo
artículo.

E Vamos a nuestro ArticleController y vamos a modificar el método
\texttt{update()}, que es donde se va a procesar el formulario cuando estemos
en modo edición. Cambiamos el tipo de respuesta a \texttt{RedirectResponse},
y añadimos \texttt{\$article->update(\$validated);} y ya está. Queda crear una
sesión con un mensaje que pasar al \texttt{index.blade.php}, y hacer la
redirección. Y eso, es todo amigos.
\begin{minted}[]{php}
<?php
/**
 * Update the specified resource in storage.
 *
 * @param  ArticleRequest $request
 * @param Article $article
 * @return RedirectResponse
 */
public function update(ArticleRequest $request, Article $article)
{
    $validated = $request->safe()->only(['title', 'content', 'category_id']);
    $article->update($validated);
    //es una línea, pero para que salga bien...
    session()->flash("success", __("El artículo ha sido" .
                                  "actualizado correctamente"));
    return redirect(route("articles.index"));
}
\end{minted}

\subsubsection{Mostrar el detalle de un artículo, cargando sus relaciones.}
\label{sec:orgfbfddfd}
Para esto vamos a usar el método \texttt{show()}; vamos al ArticleController
y cambiamos el tipo de dato devuelto a \texttt{Renderable}. Ya tenemos el
artículo en sí, porque está llegando desde la ruta y ya sólo nos queda
cargar cierta información para este artículo, la que proviene de las
relaciones. Para ello vamos a usad \texttt{load}. A esta función le pasamos
qué queremos cargar, en este caso usuario con su id y nombre y la
categoría con id y nombre, también ("user:id,name", "category:id,name").

Si no usamos load para cargar las relaciones, y usamos \texttt{dd(\$article)},
podemos ver que los datos provenientes de las relaciones están vacíos.

Esta es la forma de cargar información dinámicamente con Eloquent, el
ORM de Laravel, ya que con una sola consulta se carga todo. Si no lo
hiciéramos así, y recorriéramos, por ejemplo, una lista de etiquetas,
tendríamos un problema de rendimiento, puesto que haríamos muchas más
consultas de las necesarias. Podemos usar "Laravel Debugbar" para
verlo, así como para depurar el código.

Lo que nos queda es devolver una vista \texttt{articles.show}, que no existe
y vamos a crear, pasándole el artículo modificado..
\begin{minted}[]{php}
<?php
/**
 * Display the specified resource.
 *
 * @param Article $article
 * @return Renderable
 */
public function show(Article $article): Renderable
{
    $article->load("user:id,name", "category:id,name");
    //dd($article):
    return view("articles.show", compact("article"));
}
\end{minted}

\begin{enumerate}
\item Vista \texttt{articles.show}
\label{sec:orgff4310c}
Esta es la vista que creamos para el detalle de los artículos. No hay
mucho que destacar. Tenemos una cabecera, luego vamos metiendo, según
nos interese, los distintos campos de un artículo, contenido, usuario...,
así como un enlace para volver al index. Con esto ya está la vista de detalle.
\begin{minted}[]{xml}
<x-app-layout>
  <x-slot name="header">
    <h2 class="font-semibold text-xl text-gray-800 leading-tight">
      {{ __('Detalle artículo') }}
    </h2>
  </x-slot>

  <div class="container px-5 py-24 mx-auto flex flex-col">
    <div class="lg:w-4/6 mx-auto">
      <div class="rounded-lg overflow-hidden">
        <h1 class="text-3xl">{{ $article->title }}</h1>
      </div>
      <div class="flex flex-col sm:flex-row mt-10">
        <div class="sm:w-1/3 text-center sm:pr-8 sm:py-8">
          <div class="w-20 h-20 rounded-full inline-flex
            items-center justify-center bg-gray-200 text-gray-400">
            <svg fill="none" stroke="currentColor"
                 stroke-linecap="round" stroke-linejoin="round"
                 stroke-width="2" class="w-10 h-10" viewBox="0 0 24 24">
              <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"></path>
              <circle cx="12" cy="7" r="4"></circle>
            </svg>
          </div>
          <div class="flex flex-col items-center text-center justify-center">
            <h2 class="font-medium title-font mt-4 text-gray-900 text-lg">
            {{ $article->user->name }}</h2>
            <div class="w-12 h-1 bg-indigo-500 rounded mt-2 mb-4"></div>
          </div>
        </div>
        <div class="sm:w-2/3 sm:pl-8 sm:py-8 sm:border-l border-gray-200
             sm:border-t-0 border-t mt-4 pt-4 sm:mt-0 text-center sm:text-left">
          <span class="font-semibold title-font text-gray-400 underline">
          {{ $article->category->name }}</span>
          <p class="leading-relaxed text-lg mb-4">{{ $article->content }}</p>
          <a href="{{ route("articles.index") }}"
            class="text-indigo-500 inline-flex items-center">{{ __("Volver") }}
            <svg fill="none" stroke="currentColor" stroke-linecap="round"
                 stroke-linejoin="round" stroke-width="2"
                 class="w-4 h-4 ml-2" viewBox="0 0 24 24">
              <path d="M5 12h14M12 5l7 7-7 7"></path>
            </svg>
          </a>
        </div>
      </div>
    </div>
</x-app-layout>
\end{minted}

\newpage
\end{enumerate}

\subsubsection{Eliminar registros de la base de datos de forma correcta}
\label{sec:orgc797af9}
Vamos a ver cómo eliminar artículos desde el listado de artículos.

Primero nos vamos a \texttt{index.blade.php} y añadir una opción para poder
hacerlo. Va a ser un formulario que añadimos después de la opción de
\texttt{Editar}, tras el carácter de pipeline:
\begin{minted}[]{html}
</a> | <--
<form class="inline" method="POST"
      action="{{ route("articles.destroy", ["article" => $article]) }}">
 @csrf
 @method("DELETE")
 <button type="submit"
         class="text-red-500 inline-flex items-center mt-4">{{ __("Eliminar") }}
  <svg class="w-4 h-4 ml-2" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"
        fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path d="M5 12h14"></path>
    <path d="M12 5l7 7-7 7"></path>
  </svg>
 </button>
</form>
\end{minted}

Observad que el borrado lo hacemos con un formulario, lo ponemos
\texttt{inline} con el resto de elementos, y es de tipo \texttt{POST}, pero lo vamos
a mandar como \texttt{DELETE}, sin comprobar nada porque sólo va a tener la
función de borrar. Lo de poner un formulario y no como un enlace, es
para poder protegerlo con \texttt{@csrf} y evitar que cualquiera desde otro
sitio pueda acceder a nuestros recursos y borrarlos, con una simple
llamada \texttt{GET}, sin \texttt{csrf} ni \emph{token}, a ese enlace.

La acción del formulario, va a ser llamar directamente a la ruta
\texttt{articles.destroy} con el artículo actual. Se podría pasar sólo el
\texttt{id}, pero no es necesario, Laravel sabe qué hacer.

También definimos un botón, de tipo submit, con el texto \emph{Eliminar}
para realizar la acción.

Si borramos \texttt{@method('DELETE')} no funcionaría, probadlo.

\textbf{Mejora}, pedir confirmación del borrado. Se podría lanzar un alert, u
otro elemento para pedir la confirmación. Si se confirma el borrado ya
se llamaría a \texttt{destroy}; si no se confirma, se vuelve al listado.

Ahora vamos a crear la función llamada desde el enlace de eliminar. En
nuestro \texttt{ArticleController} vamos a dar contenido a la función
\texttt{destroy}, quedará así:
\begin{minted}[]{php}
<?php
/**
 * Remove the specified resource from storage.
 *
 * @param Article $article
 * @return RedirectResponse
 */
public function destroy(Article $article)
{
    $article->delete();
    session()->flash("success", __("El artículo ha sido eliminado correctamente"));
    return redirect(route("articles.index"));
}
\end{minted}

La primera línea es todo lo que necesitamos. La siguientes es para
mostrar un mensaje, como siempre, y finalmente volvemos a la lista de
artículos.

CRUD terminado.

\subsection{Por hacer del CRUD}
\label{sec:org822fb9a}
Quedan algunas cosas por hacer como subir un fichero, imagen... y
gestionar roles. Lo primero lo vamos a ver, lo segundo...

\section{Test funcionales con Pest Framework}
\label{sec:orgf10feb7}
Podríamos hacer todos los test de las diferentes funciones del
controlador tal y como hicimos unas páginas atrás y luego, con los
test rellenos, usar \texttt{sail test}, para ejecutar los test.

Vamos a usar una framework que se llama Pest. Trabaja sin clases, lo
que eliminar mucho código y además si estás a costumbrado a Jest en
javascript, te resultará familiar la forma de trabajar.  El elemento
para estos test son las funciones \texttt{it()} encadenadas, tantas como
queramos, con tantos test como creamos necesario.

Primero hay que \href{https://pestphp.com/docs/installation}{instalar Pest}, si no lo tenemos instalado.
\begin{minted}[]{bash}
sail composer require pestphp/pest --dev --with-all-dependencies
\end{minted}

Luego el plugin para Laravel
\begin{minted}[]{bash}
sail composer require pestphp/pest-plugin-laravel --dev
\end{minted}

Necesitamos que se cree \texttt{Pest.php} para artisan (configuración), para ello
ejecutamos:
\begin{minted}[]{bash}
sail artisan pest:install
\end{minted}


También disponemos del comando \texttt{pest:dataset} para generar datos para
las pruebas conforme se van realizando los test (usaremos factorías en
su lugar). Y para crear test usaremos \texttt{pest:test} , aunque también se
podría crear con el comando artisan general para los tests y añadir al
final \texttt{-{}-pest}. Si queremos test unitarios habría que añadir \texttt{-{}-unit}.

\subsection{Creación de los test}
\label{sec:orgf9316ef}
Vamos a crear test funcionales para el CRUD de artículos
\begin{minted}[]{bash}
sail artisan pest:test ArticleTest
\end{minted}

Nos crea un fichero con un \texttt{it()} que vamos a borrar y empezar de cero.
\subsubsection{Configuración de la BD de test (opocional).}
\label{sec:org2d192ae}

Antes de continuar vamos a abrir el fichero \texttt{phpunit.xml} y añadir, en
la etiqueta \texttt{<php>}:
\begin{minted}[]{xml}
<env name="DB_CONNECTION" value="sqlite"/>
<env name="DB_DATABASE" value=":memory:"/>
\end{minted}

Si tenemos alguno de esos atributos ya creados, con otros valores, los
comentamos.

Con esto vamos a ejecutar los tests en una BD en memoria con sqlite,
sin interferir con nuestra BD de la aplicación.

Si no nos importa, podemos dejar activa:
\begin{minted}[]{xml}
<env name="DB_DATABASE" value="testing"/>
\end{minted}

\textbf{Nota:} \\
Podemos mirar el fichero \texttt{Pest.php} donde podríamos añadir más
configuración, entre otras podríamos añadir \texttt{Dusk} para ejecutar test
en el navegador. También es posible crear un fichero \texttt{.env.testing}
para que los test lo usen en lugar  de \texttt{.env}.

Para instalar y configurar Dusk sigue este \href{https://laravel.com/docs/9.x/dusk}{enlace} y este \href{https://laravel.com/docs/9.x/sail\#laravel-dusk}{otro}

\textbf{ATENCIÓN} nunca instalar Dusk en un servidor en producción. Podría
pasar, que personas ajenas se puedan autenticar con la aplicación sin
ser usuarios.

\subsubsection{Importar y preparar los test.}
\label{sec:orgf09865f}
Lo primero es importar lo que vayamos a necesitar de Pest/laravel.
Con Pest vamos a usar funciones y no clases. De Pest:
\begin{minted}[]{php}
<?php
use App\Models\{Category, User};
use function Pest\Laravel\{actingAs, get};
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);
beforeEach(fn () => User::factory()->create());
\end{minted}
Importamos dos funciones del \emph{namespace} \texttt{Pest\textbackslash{}Laravel} como son
\texttt{actingAs} y \texttt{get}.

También podríamos importar \texttt{put}, \texttt{post}, ... Para cuando necesitemos
actuar como un usuario, por ejemplo un usuario identificado en una
zona en la que es necesaria la identificación, usaremos \texttt{actingAs}.

Las funciones \texttt{get}, \texttt{post},... nos servirán para simular peticiones
http en un CRUD.

Importamos \texttt{get} pero no el resto, luego veremos por qué.

El import de \texttt{RefreshDatabase} hará que los seeds y las migraciones se
ejecuten automáticamente cada vez que lanzan los test.

Con \texttt{beforeEach} conseguimos crear un usuario para ese test, y lo
usaremos con \texttt{actingAs}.

\subsubsection{El primer test, existe un usuario}
\label{sec:orgfcd8d32}
\begin{minted}[]{php}
<?php
it('has author')->assertDatabaseHas('users', [
  'id' => 1,
]);
\end{minted}
Con este test comprobamos que existe un usuario para nuestros test, el
que estamos creando, en la tabla de usuarios con 'id' == 1.
Podemos comprobarlo yendo a la terminal y ejecutando:
\begin{minted}[]{bash}
sail artisan test --filter ArticleTest
\end{minted}

\subsubsection{Segundo test, usuario no autenticado no tiene acceso.}
\label{sec:org77024e8}
Y nos muestra \texttt{it has author}, entre otras cosas.
Añadimos más test:
\begin{minted}[]{php}
<?php
it('user not logged cannot access to articles page', function ()
{
  get('/articles')
    ->assertRedirect('/login');
});
\end{minted}

En el primer test no añadimos un cierre (closure), pero en este
segundo test, sí añadimos una función anónima donde pondremos lo que
queremos que haga el test, en este caso comprobar que los usuarios no
identificados no pueden acceder a la página de artículos.

\subsubsection{Tercer test, usuario autenticado puede acceder al listado de artículos}
\label{sec:org109356f}
Con el siguiente test vamos a comprobar que los usuarios identificados
pueden acceder a la página de artículos:
\begin{minted}[]{php}
<?php

it('user logged can access to articles page', function ()
{
  actingAs(User::first())
    ->get('/articles')
    ->assertStatus(200);
});
\end{minted}

Vemos el uso de \texttt{actingAs} para usar al primer usuario de la BD para
idenfiticarse y acceder a la págigna (\texttt{get}). Si funciona bien
deberíamos obtener una respuesta http \texttt{200}, \texttt{assertStatus}.

\subsubsection{Tests 4º y 5º, usuario logado tiene acceso a creación de artículos y puede crearlos}
\label{sec:org797b128}
Ahora queremos asegurarnos de que un usuario identificado puede
visitar la página para crear un artículo y también que puede crear un
artículo:
\begin{minted}[]{php}
<?php
it('user logged can access to create article page', function ()
{
  actingAs(User::first())
    ->get('/articles/create')
    ->assertStatus(200);
});
//------------- comprobar que se puede crear
it('user logged can create article', function ()
{
  actingAs(User::first())
    ->post('/articles', [
      'title' => 'Article title',
      'content' => 'Article content',
      'category_id' => Category::factory()->create()->id,
    ])
    ->assertRedirect('/articles')
    ->assertSessionHas('success', 'El artículo ha sido creado correctamente');
});
\end{minted}

Para comprobar la creación de artículos, vamos a actuar como el primer
usuario que encontremos en BD y encadenamos una función \texttt{post()}; le
estamos diciendo que hacemos una petición post con una serie de datos
para almacenar en BD con lo que le estamos diciendo que ejecute la
función \texttt{store} del ArticleController. Si todo va bien se nos
redirecciona a la página de articles y tenemos que ver una sesión con
el nombre \texttt{'success'} y el título \texttt{'El artículo ha sido creado
correctamente'}.

\subsubsection{Tests 6º y 7º, usuario logado tiene acceso a edición de artículos y puede editarlos}
\label{sec:orgf51ef37}
Para comprobar que se puede acceder a la página de editar un artículo,
primero creamos uno, luego accedemos a la página. Para comprobar que
se puede editar haremos lo mismo, pero en esta ocasión si lo
editamos. Observad el omnipresente \texttt{actingAs}:
\begin{minted}[]{php}
<?php
it('user logged can access to edit article page', function ()
{
  $user = User::first();
  $article = $user->articles()->create([
    'title' => 'Article title',
    'content' => 'Article content',
    'category_id' => Category::factory()->create()->id,
  ]);

  actingAs($user)
    ->get("/articles/{$article->id}/edit")
    ->assertStatus(200);
});
//------------- comprobar que se puede editar
it('user logged can edit article', function ()
{
  $user = User::first();
  $article = $user->articles()->create([
    'title' => 'Article title',
    'content' => 'Article content',
    'category_id' => Category::factory()->create()->id,
  ]);

  actingAs($user)
    ->put("/articles/{$article->id}", [
      'title' => 'Article title updated',
      'content' => 'Article content updated',
      'category_id' => Category::factory()->create()->id,
    ])
    ->assertRedirect('/articles')
    ->assertSessionHas('success', 'El artículo ha sido actualizado correctamente');
});
\end{minted}

\subsubsection{Último test, por el momento, el lusuario puede borrar.}
\label{sec:org49992a4}
Ahora a probar el borrado
\begin{minted}[]{php}
<?php
it('user logged can delete article', function ()
{
  $user = User::first();
  $article = $user->articles()->create([
    'title' => 'Article title',
    'content' => 'Article content',
    'category_id' => Category::factory()->create()->id,
  ]);

  actingAs($user)
    ->delete("/articles/{$article->id}")
    ->assertRedirect('/articles')
    ->assertSessionHas('success', 'El artículo ha sido eliminado correctamente');
});

\end{minted}

Para que se pueda borrar necesitamos que exista previamente un
artículo que borrar, por ello, en primer lugar lo creamos y luego
procedemos con el borrado.


\newpage

\section{{\bfseries\sffamily TODO} Subida de imagenes}
\label{sec:orgf547601}
Para poder subir imágenes necesitamos dar una serie de pasos.
\begin{itemize}
\item Crear un proyecto, nuestro blog.
\item Instalar Spatie Media Library
\item Actualizar la BD
\item Crear formulario subida imagen
\end{itemize}

\subsection{Crear proyecto}
\label{sec:org4c88037}
Nada que hacer, ya esta:-).

\subsection{Modelo el formulario de registro}
\label{sec:org73a1a12}
Necesitamos añadir un campo para la subida de la imagen. Buscamos el
formulario de registro, que están en una vista (resources/views/auth),
\texttt{register.blade.php} y allí vamos a añadir (bajo el campo que queráis)
lo siguiente:
\begin{minted}[]{html}
<!-- Avatar Image -->
 <div class="mt-4">
   <x-input-label for="email" :value="__('Avatar')" />

   <x-text-input id="avatar" class="block mt-1 w-full" type="file"
                 name="avatar" :value="old('avatar')" />

   <x-input-error :messages="$errors->get('avatar')" class="mt-2" />
 </div>
\end{minted}
Yo lo he añadido debajo de la petición del nombre. Adicionalmente se
le pueden modificar los css, clases tailwind, del botón para que salga
más bonito.

También hay que destacar que no he puesto \texttt{required}.

Para que funcione no hay que olvidar modificar el formulario para que
sea "multipart/form-data":
\begin{minted}[]{html}
<form method="POST" action="{{ route('register') }}" enctype="multipart/form-data">
\end{minted}


\subsection{Spatie Laravel Media Library, para subida de ficheros de imágenes}
\label{sec:org0af49a3}
Laravel Media Library es un paquete poderoso y gratuito que puede
asociar todo tipo de archivos con modelos Eloquent. Además de eso,
puede generar miniaturas e imágenes "responsivas".¡También puede rastrear
todos sus medios en todos los sistemas de archivos, y mucho más!
...

\subsubsection{Instalación y configuración}
\label{sec:org2987767}
\begin{enumerate}
\item Instalación:
\label{sec:org968bcc1}
\begin{minted}[]{bash}
sail composer require "spatie/laravel-medialibrary:^10.0.0"
\end{minted}

\item Preparar la base de datos.
\label{sec:org760cc4a}
\begin{minted}[]{bash}
sail artisan vendor:publish \
--provider="Spatie\MediaLibrary\MediaLibraryServiceProvider" \
--tag="migrations"
\end{minted}
\item Ejecutar las migraciones (crea tabla para los medios).
\label{sec:org5dc04db}
\begin{minted}[]{bash}
sail artisan migrate
\end{minted}

Generará una tabla de base de datos llamada media que usa \textbf{\href{https://appdividend.com/2018/05/18/laravel-polymorphic-relationship-tutorial-example/}{Polymorphic
Relations}} para almacenar los datos. Puedes ver un error como este:

\begin{verbatim}
Error : [Illuminate\Database\QueryException]
SQLSTATE[42000]: Syntax error or access violation: 1064 You have an
error in your SQL syntax; check the manual that corresponds to your
MariaDB server version of the right syntax to use ‘json not null,
custom_properties json not null, order_column int unsigned nu’ at line
1 (SQL: create table m edia(id int unsigned not null auto_increment
primary key, model_id int unsigned not null, model _typevarchar(191)
not null, collection_name varchar(191) not null, name varchar(191) not
null, file_namevarchar(191) not null, mime_type varchar(191)
null, disk varchar(191) not null, size int unsigned not
null, manipulations json not null, custom_properties json not
null, order_column int unsigned null, created_at timestamp
null, updated_at timestamp null) default character set u tf8mb4
collate utf8mb4_unicode_ci)
\end{verbatim}

Posible solución: cambiar el tipo de datos de \texttt{json} a \texttt{text} en la
base de datos >> migración >> \texttt{archivo create\_media\_table.php}.

\item Publicar el fichero de configuración.
\label{sec:org0163346}
Es un paso opcional, pero lo vamos a hacer porque pretendemos cambiar
el \texttt{disk} donde se guardan los archivos.
\begin{minted}[]{bash}
sail artisan vendor:publish \
--provider="Spatie\MediaLibrary\MediaLibraryServiceProvider" \
--tag="config"
\end{minted}

Esta es la configuración por defecto del disco donde se van a guardar
los "medios";

\begin{minted}[]{php}
<?php
/*
     * The disk on which to store added files and derived images by default. Choose
     * one or more of the disks you've configured in config/filesystems.php.
     */
    'disk_name' => env('MEDIA_DISK', 'public'),
...
\end{minted}

\newpage
\end{enumerate}

\section{Subida de imagen de avatar}
\label{sec:orgf70641a}
Para poder poner una imagen de usuario en el perfil, avatar,
necesitamos dar una serie de pasos.
\begin{itemize}
\item Modificar el formulario de registro
\begin{itemize}
\item Crear un componente y usarlo en el formulario
\item Validación de la imagen en el formulario
\end{itemize}
\item Actualizar la BD y el almacenamiento
\begin{itemize}
\item Crear una migración
\item Cambiar el modelo de usuario, User
\item Configurar el espacio de almacenamiento
\end{itemize}
\item Mostrar una imagen miniatura, thumbnail, junto al nombre
\end{itemize}

\subsection{Modificación formulario registro de Breeze}
\label{sec:org849ddf6}
Vamos a modificar el formulario de registro de Breeze para poder
añadir una imagen avatar para el usuario. Hay algunas cosas no
necesarias, como la visualización al subir, pero así trabajamos un
poco con Alpine.js, que es el mini framework JavaScript que viene con
Laravel. Adicionalmente vamos a ver cómo se crea un component

\textbf{Tutorial vídeo para modificar Breeze registration form}.
Seguimos el vídeo \url{https://www.youtube.com/watch?v=rbG0wWbPo-U}

\subsubsection{Crear componente input para imagen}
\label{sec:orgc78b834}
Vamos a crear un componente para la subida de la imagen del
avatar. Primero lo creamos con artisan:
\begin{minted}[]{bash}
sail artisan make:component avatar-input --view
\end{minted}

Con \texttt{-{}-view} le indicamos que sólo queremos la vista
correspondiente. Si no ponemos \texttt{-{}-view}, nos crearía la clase
correspondiente. Esto nos serviría en caso de querer pasar parámetros
al componente para usarlo de plantilla... En este caso nos basta con
la vista.

Para rellenar la vista, primero vamos a \href{https://heroicons.com/}{heroicons.com} y escogemos un
icono para la subida de archivos, pinchamos sobre él y copiamos el
"svg", o "jsx" si es para usar con React.

Abrimos \texttt{avatar-input.blade.php} que está en
\texttt{resources/views/components}, y lo editamos metiendo en él, el
componente que acabamos de bajar.

Observad el cambio de \texttt{x-button} por \texttt{x-primary-button}, en nuestra
instalación de breeze, se instala el segundo component y no el que
usan en el vídeo.

\begin{minted}[]{html}
<div class="flex items-center" x-data="picturePreview()">
  <div class="rounded-md bg-gray-200 mr-2">
    <img id="preview" src="" alt=""
         class="w-24 h-24 rounded-md object-cover">
  </div>
  <div>
   <x-primary-button
      @click="document.getElementById('avatar').click()"
     class="relative">
      <div class="flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg"
             fill="none" viewBox="0 0 24 24"
             stroke-width="1.5" stroke="currentColor"
             class="w-6 h-6 mr-2">
          <path stroke-linecap="round" stroke-linejoin="round"
                d="M12 16.5V9.75m0 0l3 3m-3-3l-3
                   3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0
                   0110.233-2.33 3 3 0 013.758 3.848A3.752
                   3.752 0 0118 19.5H6.75z" />
        </svg>
        Subir imagen
      </div>
      <input @change="showPreview(event)"
             type="file" name="avatar"
             id="avatar" class="absolute inset-0 -z-10 opacity-0">
   </x-primary-button>
</div>
  <script>
    function picturePreview() {
      return {
        showPreview: (event) => {
          if (event.target.files.length > 0)
            var src = URL.createObjectURL(event.target.files[0]);
          document.getElementById('preview').src = src;
        }
      }
    }
  </script>
</div>
\end{minted}
Hay que destacar que no he puesto \texttt{required} en el input.

\subsubsection{Modificar barra de navegación}
\label{sec:org1da2233}
En \texttt{navigation.blade.php}, buscamos la sección \texttt{Settings Dropdown}, y
ahí donde está
\begin{minted}[]{html}
<div>
  {{ Auth::user()->name }}
</div>
\end{minted}

vamos a añadir la imagen del avatar, justo delante, pero como no es un
campo obligatorio, tenemos que comprobar que existe con una directiva
\texttt{if} de Blade:

\begin{minted}[]{html}
<div class="flex items-center">
  @if(Auth::user()->avatar)
   <img src="{{ asset(Auth::user()->avatar) }}" alt=""
        class="w-8 h-8 rounded-full object-cover mr-2">
  @endif
  <div>
   {{ Auth::user()->name }}
  </div>
</div>
\end{minted}

\subsubsection{Modificar el formulario de registro}
\label{sec:org6b8569b}
Lo añadimos justo encima de la petición del nombre. Podéis comprobar
que lo único que necesitamos hacer es poner el componente que hemos
creado.
\begin{minted}[]{html}
<!-- Avatar Image -->
 <x-avatar-input />
<!-- Name -->
\end{minted}

Para que funcione hay que modificar el formulario para que
sea \texttt{multipart/form-data}:
\begin{minted}[]{html}
<form method="POST" action="{{ route('register') }}"
enctype="multipart/form-data">
\end{minted}

\subsubsection{Validar el campo del avatar en el formulario}
\label{sec:orgd7b2708}
Tenemos que modificar la validación para añadir el nuevo campo. La
validación del registro de un usuario se hace en
\texttt{RegisteredUserController.php}. Buscamos la función \texttt{store} y la
modificamos para que nos quede así:
\begin{minted}[]{php}
<?php
public function store(Request $request): RedirectResponse
{
    $request->validate([
        'name' => ['required', 'string', 'max:255'],
        'email' => ['required', 'string', 'email', 'max:255', 'unique:'.User::class],
        'password' => ['required', 'confirmed', Rules\Password::defaults()],
        'avatar' => ['file','mimes:jpg,png,gif','max:3072']
    ]);

    $path=null;
    if($request->hasFile('avatar')) {
      $path = $request->file('avatar')->storePublicly('avatars');
    }

    $user = User::create([
        'name' => $request->name,
        'email' => $request->email,
        'password' => Hash::make($request->password),
        'avatar'  => $path ,
    // isset($request->avatar) ? ($request->avatar) : 'defaultAvatar.png'
    ]);

    event(new Registered($user));
    Auth::login($user);
    return redirect(RouteServiceProvider::HOME);
}
\end{minted}

Con la línea:
\begin{minted}[]{php}
<?php
'avatar' => ['file','mimes:jpg,png,gif','max:3072']
\end{minted}

, indicamos que el campo es de tipo fichero, los tipos aceptable son
jpg, png y gif. El tamaño máximo aceptado será de 3072 KB.

Las líneas:
\begin{minted}[]{php}
<?php
$path=null;
    if($request->hasFile('avatar')) {
      $path = $request->file('avatar')->storePublicly('avatars');
    }
\end{minted}

, sirven para comprobar si se está subiendo una imagen. Si se sube se
obtiene su path y se almacena en el disco configurado.

El siguiente paso es crear y guardar el nuevo usuario en la BD con el
nuevo campo \texttt{avatar}.
\begin{minted}[]{php}
<?php
...
'avatar'  => $path ,
...
\end{minted}


\subsection{Modificación BD}
\label{sec:orgea863ea}
Creamos una nueva migración para añadir la columna "avatar" a la tabla
de usuarios. Normalmente no haría falta especificar la tabla, ya que
usamos la convención de Laravel para las migraciones.

\subsubsection{Migraciones}
\label{sec:org6ae8548}
\begin{minted}[]{bash}
sail artisan make:migration add_avatar_to_users_table --table=users
\end{minted}

En la migración recién creada ponemos en la función \texttt{up()}
\begin{minted}[]{php}
<?php
$table->string('avatar')->nullable(); //podriamos poner una imagen por defecto
\end{minted}

Luego actualizamos las migraciones:
\begin{verbatim}
sail artisan migrate
\end{verbatim}

\subsubsection{Modelo User}
\label{sec:orgda33ec3}
También necesitamos un mínima modificación en el modelo \texttt{User},
añadir el campo \texttt{avatar} a la variable \texttt{\$fillable}, :
\begin{minted}[]{php}
<?php
protected $fillable = [
        'name',
        'email',
        'password',
        'avatar',
    ];
\end{minted}

\subsubsection{Configurar los discos}
\label{sec:orgec3fd65}
En \texttt{config/filesystems.php}, tenemos toda la configuración para
espacios de almacenamiento en Laravel. Podéis ver más en la
documentación de Laravel, o en la documentación del curso pasado.
Buscamos, al final, la sección \texttt{links} y Vamos a añadir esto:
\begin{minted}[]{php}
<?php
'links' => [
        public_path('avatars') => storage_path('app/avatars'),
        public_path('storage') => storage_path('app/public'),
    ],
\end{minted}
La segunda fila no es necesario salvo que vayamos a guardar otras
cosas diferentes a los avatares.

Si no queremos tener que andar configurando discos y creando rutas
para acceder a los ficheros, puesto que la página sólo tiene acceso a
la parte del directorio \texttt{public}, vamos a hacer lo siguiente para que
los directorios \texttt{storage/avatars} y \texttt{storage/publilc} sean accesibles
sin muchas vueltas:
\begin{minted}[]{bash}
sail artisan storage:link
\end{minted}

\subsubsection{Diseño «responsivo»}
\label{sec:orgac6aac7}
Si queremos que aparezca el avatar en la vista responsiva (móvil)
vamos a \texttt{navigation.blade.php}, buscamos donde se expone el nombre y
poner:
\begin{minted}[]{html}
<!-- Responsive Settings Options -->
<div class="pt-4 pb-1 border-t border-gray-200">
  <div class="px-4">
    @if(Auth::user()->avatar)
      <img src="{{ asset(Auth::user()->avatar) }}" alt=""
           class="w-8 h-8 rounded-full object-cover mr-2">
      <div>{{ Auth::user()->name }}</div>
    @endif
    <div class="font-medium text-base text-gray-800">
      {{ Auth::user()->name }}
    </div>
    <div class="font-medium text-sm text-gray-500">
      {{ Auth::user()->email }}
    </div>
</div>
\end{minted}

\newpage


\section{Anexo I}
\label{sec:orgc9584b2}
\subsection{Herramientas, librerías etc.}
\label{sec:org0b03ed5}
\subsubsection{Cliente}
\label{sec:orgee6c190}
\begin{itemize}
\item \href{https://bladewindui.com/}{BladeWind}: Librería, simple y elegante, de components
Blade+Tailwind y JS sin librerías. Ejemplos en este \href{https://www.youtube.com/watch?v=UoKa5aKkv1U}{vídeo}.
\end{itemize}



\url{https://appdividend.com/2018/06/02/laravel-avatar-image-upload-tutorial-with-example/}

\url{https://www.itsolutionstuff.com/post/laravel-profile-image-upload-tutorial-with-exampleexample.html}

\url{https://www.positronx.io/laravel-upload-images-with-spatie-media-library-tutorial/}

\url{https://spatie.be/courses/discovering-laravel-media-library/introducing-laravel-media-library}

\url{https://www.itsolutionstuff.com/post/how-to-add-extra-field-in-registration-form-in-laravelexample.html}

Customize registration and login
\url{https://dev.to/kingsconsult/customize-laravel-auth-laravel-breeze-registration-and-login-1769}


\newpage


\section{Anexo II}
\label{sec:org4568954}
\subsection{Pasos tras clonar un repositorio de un proyecto Laravel sail}
\label{sec:org4be2a6d}
Cuando subimos un proyecto hecho con Laravel sail, hay ciertas partes
que no se suben al repositorio, como binarios, librerías, dependencias
y ficheros de configuración con información sensible como el
\texttt{.env}. Por esto, una vez clonado el repositorio tendremos que hacer
algunas cosas, a saber:

\begin{enumerate}
\item Rehacer la información del \texttt{.env}
\begin{enumerate}
\item Información de los servidores, contraseñas etc., deberemos
copiar el fichero \texttt{.env.example} a \texttt{.env}, ver qué servicios
tenemos activos en nuestro \texttt{docker-compose.yml} y cambiar la
información correspondiente en el nuevo \texttt{.env}, por ejemplo
para el servicio de BD con MySQL, los datos a rellenar son:
\begin{minted}[]{bash}
DB_CONNECTION=mysql
DB_HOST=/ mysql /
DB_PORT=3306
DB_DATABASE=/ blog_laravel9 /
DB_USERNAME=/ sail /
DB_PASSWORD=/ password /
\end{minted}
Entre \emph{/ /} los datos que hay que cambiar, he puesto sus
valores correctos, pero recuerda que no tendrá datos
adecuados cuando empecemos a editarlo.
\item Ejecutar \texttt{composer} para instalar todo el aparataje de
Laravel, binarios, librerías, scripts..., incluido \texttt{sail}
para poder trabajar en el proyecto. Si el proyecto estuviera
en su totalidad en el contenedor, o tuviéramos \texttt{composer} y
php instalado en la máquina un simple \texttt{composer install}
sería suficiente. Pero nuestro proyecto está fuera de los
contenedores, que es donde está PHP, así que tenemos que
hacerlo de otra manera, con un contenedor donde está PHP y
composer. La versión de PHP debe ser la misma con la que se
creó el proyecto.
\begin{minted}[]{bash}
docker run --rm \
-u "$(id -u):$(id -g)" \
-v "$(pwd):/var/www/html" \
-w /var/www/html \
laravelsail/php81-composer:latest \
composer install --ignore-platform-reqs
\end{minted}
\item Ya tenemos lo necesario para ejecutar y levantar el proyecto con
\begin{minted}[]{bash}
sail up
# o
sail up -d
\end{minted}
\item Una de las partes que no se preserva es la variable
\texttt{APP\_KEY=}, que deberemos regenerar:
\begin{minted}[]{bash}
sail artisan key:generate
\end{minted}
\item Ahora rehacemos la BD con las migraciones y las semillas, si
tenemos \emph{seeders}:
\begin{minted}[]{bash}
sail artisan migrate:fresh --seed
\end{minted}
Normalmente \emph{fresh} no sería necesario en este caso, pero por
si las moscas.
\item Si hemos instalado Breeze u otro componente que trabaje con
el \emph{frontend}, deberemos instalar las dependencias de \texttt{node}
y ejecutar el servicio de desarrollo.
\begin{minted}[]{bash}
sail npm install
sail npm run dev
\end{minted}
Si tenemos \texttt{yarn} en lugar de \texttt{npm}:
\begin{minted}[]{bash}
yarn #o yarn install
yarn dev #o yarn run dev
\end{minted}
Nota 1:
Yarn es más seguro, eso dicen, y puede bajar las dependencias
y hacer el build en paralelo, con lo que es más rápido.

Nota 2:
Cuando el proyecto pase producción se ejecutará \texttt{node}, o \texttt{yarn},
con la opción \texttt{prod} o \texttt{produdction}, eso generará las partes
del front definitivas, que deberemos copiar en el sitio
correspondiente del proyecto, directorios para JavaScript y CSS.
\end{enumerate}
\end{enumerate}

Si falta algo, se irá añadiendo en este documento.
\end{document}
